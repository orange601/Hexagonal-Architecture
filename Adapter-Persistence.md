출처: https://velog.io/@jummi10/%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-Ch-06.-%EC%98%81%EC%86%8D%EC%84%B1-%EC%96%B4%EB%8C%91%ED%84%B0-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0

# 영속성 어댑터 #
- 전통적인 계층형 아키텍처 → 데이터베이스 주도 설계
- 육각형 아키텍처 → 의존성을 역전시켜 영속성 계층을 애플리케이션 계층의 플러그인으로 작동

## 영속성 어댑터의 책임 ##
- 입출력 모델이 영속성 어댑터가 아닌 애플리케이션 코어에 있다.
1. 포트 인터페이스를 통해 입력을 받는다
2. 입력을 데이터베이스 포맷으로 매핑한다
    - 입력 모델: 인터페이스가 지정한 도메인 엔티티/특정 데이터베이스 연산 전용 객체
    - 애플리케이션 코어에 존재. 영속성 어댑터 변경이 코어에 영향을 미치지 않음.
    - 데이터베이스 포맷: JPA 엔티티 객체
3. 입력을 데이터베이스로 보낸다
4.데이터베이스 출력을 애플리케이션 포맷으로 매핑한다
    - 포트에 정의된 출력 모델이 애플리케이션 코어에 위치한다.
5. 출력을 반환한다

## 의존성 역전 ##
- application.service.Service →(호출) application.port.out.OutgoingPort ←(구현) adapter.out.persistence.OutgoingAdapter
- 영속성 어댑터 = 주도되는/아웃고잉 어댑터
- 포트: 애플리케이션 서비스가 영속성 문제(의존성) 없이 도메인 코드를 개발하기 위한 간접 계층 ( 코어에 영향을 미치지 않으면서 영속성 계층 수정 가능 )


## 포트 인터페이스 나누기 ##
- ISP (인터페이스 분리 법칙) : 클라이언트가 오로지 자신이 필요로 하는 메서드만 알면 되도록 넓은 인터페이스를 특화된 인터페이스로 분리해야 한다.

### 인터페이스 분리 전 ###
- 하나의 리포지토리 인터페이스를 관련된 모든 서비스에서 사용
- 각 서비스는 필요 없는 리포지토리의 메서드들에까지도 불필요한 의존성을 가지게 된다.
- 특정 서비스를 단위 테스트하기 위해 리포지토리를 모킹할 때도 문제가 된다.

### 인터페이스 분리 후 ###
- 포트에 필요한 메서드만 존재하며 포트의 이름이 역할을 잘 나타낸다.
- plug-and-play: 재설정하거나 조정하는 과정 없이 연결하는 즉시 완벽하게 작동하는 방식 ( 서비스 코드를 필요한 포트에 그저 꽂기만 하면 된다. )
- AccountRepository는 영속성 어댑터에서 포트를 구현하면서 사용하게 된다.

## 영속성 어댑터 나누기 ###
- 영속성 어댑터를 각 영속성 기능을 이용하는 도메인 경계를 따라 나눈다.
- 하나의 애그리거트(도메인 클래스)당 하나의 영속성 어댑터 혹은 JPA 어댑터 하나&SQL 어댑터 하나
- 여러 개의 bounded context(도메인간의 경계)의 영속성 요구사항을 분리하기 좋은 토대가 된다.

## 스프링 데이터 JPA 예제 ##

### 도메인 모델 ↔ 데이터베이스 모델 양방향 매핑 ##
- 풍부한 도메인 모델을 위해서
#### 매핑하지 않으면? #### 
- JPA로 인해 도메인 모델을 타협해야 한다.
    1. JPA 엔티티는 기본 생성자를 필요로 한다.
    2. 영속성 계층: @ManyToOne 관계 설정
    3. 도메인 모델: 데이터의 일부만 가져오고 싶어서 반대의 관계를 원할 수도 있음
