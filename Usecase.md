출처: https://injae7034.github.io/java/wooa_study_04/

# 유스케이스 #
유스케이스 구현은 도메인 로직 구현 + 비즈니스 규칙 검증

비즈니스 규칙 검증과 입력 유효성 검증은 다르다.

## 유스케이스 구현 ##
1. 입력을 받는다
2. 비즈니스 규칙을 검증한다
3. 모델 상태를 조작한다
4. 출력을 반환한다

### 1. 입력을 받는다. ###
- 컨트롤러(어댑터)로부터 입력받는다.
- 유효성 검증은 유스케이스의 책임이 아니다.
- 유스케이스 코드는 도메인 로직에만 집중

### 2. 비즈니스 규칙을 검증 (입력 유효성 검증이 아니다) ###
- 유스케이스 코드에서 비즈니스 규칙은 검증해야할 책임이 있고, 이 책임을 도메인 엔티티와 공유

### 3. 모델 상태 조작 ###
- 비즈니스 규칙이 충족되면 유스케이스는 인커밍 어댑터(컨트롤러)로부터 받은 입력을 바탕으로 모델의 상태를 변경
- 도메인 객체의 상태를 바꾼 다음 이를 영속성 계층에 바뀐 사항을 저장하기 위해 아웃고잉포트(리포지토리 인터페이스)를 유스케이스에서 호출하면 실제로 이를 구현한 아웃고잉 어댑터(데이터베이스 또는 다른 저장소)가 이 변경사항을 저장

### 4. 출력 반환 ###
- 유스케이스를 호출한 어댑터인 컨트롤러에 반환할 값을 출력객체로 변환하는 작업을 진행한다.


## 입력 유효성 검증 ( 비즈니스규칙 검증이 아니다) ##
- 입력 모델에서 입력 유효성 검증하기
  + 입력 모델이란 validation을 체크하는 DTO 혹은 데이터 전달 객체
  + 입력 유효성 검증은 유스케이스 클래스의 책임은 아니지만 **애플리케이션 계층의 책임**에는 해당한다.
  + 유스케이스를 호출하는 컨트롤러가 하나일 수도 있지만 프로그램이 복잡해지다보면 UseCase를 호출하는 컨트롤러가 여러 개일 수도 있다.
  + 그러면 UseCase를 호출하는 모든 컨트롤러에서 유효성을 검증하는 코드를 작성해야 하기 때문에 코드 중복이 심해지고, 유효성 검증하는 코드를 빼먹어서 유효하지 않은 입력값을 받게 되어 모델의 상태를 해치는 문제가 발생한다.
  + 그래서 입력 모델을 만들어 애플리케이션 계층에서 입력 유효성을 검증하도록 해야 한다.

- 빌더 사용을 지양
  + 컴파일러는 유효하지 않은 상태의 불변 객체를 만드는 것에 대해 경고하지 못한다.

- 직접 생성자 사용
  + 새로운 필드를 추가하거나 삭제할 때, 컴파일 에러가 코드를 수정할 수 있게 도와준다.


## 유스케이스 입력 모델 ##

### 1. 다른 유스케이스에서 같은 입력 모델을 사용할 경우 ###
- 재사용한 입력 모델에서 필요하지 않은 필드를 null을 유효한 상태로 받아들여야
- 다른 입력 유효성 검증이 필요할 경우 유스케이스 코드에 들어갈 수 있게 된다.

### 2. 유스케이스마다 전용 입력 모델을 사용할 경우 ###
- 다른 유스케이스와의 결합 제거
- 유스케이스를 훨씬 명확하게 만든다.
- 장기적으로 유지보수하기 더 쉽다.
- 하지만, 더 많은 비용이 든다.


## 비즈니스 규칙 검증 ##
- 비즈니스 규칙의 위치는 **비즈니스 로직이 있는 도메인 엔티티**

### 1. 입력 유효성 검증 ###
- 도메인 모델의 현재 상태에 접근하지 않는다. (ex. 송금되는 금액은 0보다 커야 한다.)
- 선언적(ex. @NotNull)으로 구현 가능
- 구문상의(syntactical) 유효성을 검증

### 2. 비즈니스 규칙 검증 ###
- 도메인 모델의 현재 상태에 접근한다. (ex. 출금 계좌는 초과 출금되어서는 안 된다. 계좌가 존재해야 한다. )
- 유스케이스 맥락 속에서 의미적인(semantical) 유효성을 검증

## 풍부한 도메인 모델 vs. 빈약한 도메인 모델 ##
- 각자 필요에 맞는 방법을 자유롭게 사용하라.

### 1. 풍부한 도메인 모델 ###
- DDD
- 엔티티에서 가능한 한 많은 도메인 로직과 비즈니스 규칙을 구현
- 유스케이스 = 도메인 모델의 진입점
  + 도메인 엔티티의 메서드 호출

### 2. 빈약한 도메인 모델 ###
- 얇은 엔티티
  + 필드, getter, setter
  + 도메인 로직 포함 X → 유스케이스에 구현됨
- 풍부한 유스케이스 클래스
